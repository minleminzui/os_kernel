>互联网冲浪多年，苦苦寻找捷径，想要学会编程，到头来发现，完全没有捷径呢，学编译原理，需要学会写编译器，学os，需要写一个kernel，学图形学，需要实现renderer，学网络，需要实现网络库，webserver。code，code，code！！！
# 零 一些你可能正在迷惑的问题
## 0.9 物理地址，逻辑地址，有效地址，线性地址，虚拟地址的区别
- `物理地址：`物理内存的真实地址，CPU最终需要以物理地址去访问内存。
- `逻辑地址/有效地址：`无论是在实模式还是在保护模式下，段内偏移地址又称为有效地址，也成为**逻辑地址**。
- `线性地址/虚拟地址：`它们不是真实的地址，它们用来描述程序或任务的地址空间。
## 0.10 是什么是段重叠
- `段重叠：`![](picture/%E6%AE%B5%E9%87%8D%E5%8F%A0.jpg)
## 0.11 什么是平坦模式？
- `平坦模式：`相对于多段模型而言，可以理解为**单段模式**，不需要切换**段基址**，以及额外打开**A20地址线**？
## 0.12 cs,ds 这类sreg段寄存器，位宽是多少
- CS, DS, ES, FS, GS, SS段寄存器，在**实模式**下，是**段基址**，而在**保护模式**下，是**段选择子（Selector）**，也就是通过选择子，可以在GDT中找到相应的段描述符，在该描述符中记录了段的起始，大小等信息，于是便得到了段基址。在32位CPU中，段寄存器的位宽都是16位。
## 0.13 什么是工程，什么是协议
- `工程：`就是为了完成软件编写所涉及的全部相关文件。
- `协议：`一种大家都共同遵守的规约，主要用来实现通信，共享，协作；起初是为了避免大家各干各的，无法彼此调用对方成果的情况，从而给大家统一一种接口，一组数据调用或者分析的约定。
## 0.14 为什么Linux系统下的英勇程序不饿能在Windows系统下运行
- 主要是因为Linux的可执行文件是ELF，而Windows是PE；它们的**API**也不一样，Linux的API是系统调用，采用int 0x80中断实现，而Windows的API是在DLL中，**DLL不是可执行文件，不能够单独使用**；除此之外，还有编译器，标准库等的不同。
## 0.15 局部变量和函数参数为什么要放在栈中
- 由于这些变量只由这些函数自己使用，这是**局部性原理**；并且在函数调用之前，并不知道该函数需要使用多少内存存储这些变量。
## 0.16 为什么说汇编语言比C语言更快
- 汇编并没有比C语言运行的更快，而是生成的**指令数更少**；而C语言为了程序员的便利，额外做了大量的工作，所以会加入额外代码。
## 0.17 先有的语言，还是先有的编译器，第一个编译器怎么产生的
- 编译器可以编译出新的编译器，这种自己创造自己的现象称为**自举**。
- 用旧的编译器去**训练编译**新的编译器
## 0.18 编译性程序与解释型程序的区别
- 解释型语言，也叫脚本语言，它们都是**脚本解释器**的输入文件，脚本解释器实时分析这个脚本。**浏览器**之于JS，就如**PHP解释器**之于PHP
- **编译型语言**会生成二进制文件
## 0.19 什么是大端字节序，小段字节序
- `小端序：`低字节放在内存低地址，高字节放在内存高地址。**优势在于**强制转换数据类型时不需要要调整字节。**bmp图片**采用小端序。
- `大端序：`与小端序相反。**优势是**符号位易取出。**jepg图片**采用大端序。**网络传输采用大端序，所以在x86架构上的程序发送网络数据时，需要转换字节序**
## 0.20 BIOS中断，DOS中断，Linux中断的区别？
- `BIOS中断：`计算机启动之初，BIOS在中断向量表（IVT）中建立中断例程，它从物理内存0x0000处初始化并在中断向量表中添加各种例程。BIOS中断调用的主要功能时提供了硬件的访问方法，使得访问硬件更加简单，虽然通过in/out指令也可以来读写外设的端口
- `DOS中断：`其也是在**实模式**下运行，其建立的中断调用也是在中断向量表（IVT），占用**0x21中断号**
- `Linux中断：`处于**保护模式**，通过**int 0x80指令**进入一个中断程序，在根据eax寄存器的值来调用不同的子功能函数，不过这时访问的时**中断描述符表（IDT）**，也就是说在**保护模式下执行int指令会去访问IDT，而实模式下时IVT**
## 0.21 Section和Segment的区别
- `section：`编译器将高级语言编译汇编，其中汇编器将汇编语言中逻辑划分指令或数据区域，**section**处于**目标文件**。
- `segment：`**链接器**将各个seciton根据器属性，将多个seciton合并到一个segment，所以segment处于**可执行文件**中
- 在汇编代码中如果以标准节名定义seciton，比如**.bss**，编译器会将其放到**.bss**中
## 0.22 什么是魔数
- 比如，在ELF文件的开头，存在着这样的数字![](picture/ELF%E9%AD%94%E6%95%B0.jpg),那么**ELF解析器(通常是程序加载器)**用它来检验文件的类型是否是elf。
## 0.23 操作系统是如何识别文件系统的
- 通过检查文件系统分区的第1个扇区便是超级块的起始扇区，其中便纪录了文件系统的**魔数**
## 0.24 如何控制CPU的下一条指令
- 在x86体系结构中，PC指的是一组寄存器，段寄存器CS和指令寄存器IP。不能够使用`mov`去改变CS:IP，但是可以用`jmp，call，int，ret`去改变，它们在硬件层面实现了原子操作。PC是获取下一条指令的方法形式，在不同的体系结构的CPU中有不同的实现方法。
## 0.25 指令集，体系结构，微架构，编程语言
- `指令集：`指令集是具体的一套指令编码，微架构是指令集的物理实现方式。对于x86这样的指令集，它本身是RISC指令，但是由于效率过低，最终其内部实现采取了RISC内核，即一条CISC指令在译码时，分解成多条RISC指令。**CPU与指令集对应，一种CPU只能识别一种指令集**
- 编程语言，底层需要运行在CPU之上，所以必须要编译器按照该CPU的指令集，翻译存储符合该CPU的指令。
- `交叉编译：`就是指在A平台上运行的编译器，编译处符合B平台CPU指令集的程序，编译处的程序直接能在B平台上运行。这里的平台就是指CPU指令体系结构。
## 0.26 库函数时用户进程与内核的桥梁
- **库函数**帮助写下了调用系统调用的代码
- **extern关键字：**它的作用仅仅只是告诉编译器，该关键字修饰的变量，应该在**链接**的时候去找**定义**![](picture/extern%E5%92%8Cinclude%E5%85%B3%E9%94%AE%E5%AD%97.jpg)
- `运行时库：`是程序在运行时所需要的库，该库是由众多可复用的函数文件组成，由编译器提供。在Linux环境下，gcc可以提供C语言的运行时。
- 尽管系统调用封装在库函数中，但用户程序可以直接调用“系统调用”，不过用函数会比较高效。
## 0.27 转移字符和ASCII码
- `转义字符：`在ASCII码中，如何将不可见的字符**写**出来，使用`\`这个转义字符，比如`\n`表示换行符
## 0.28 MBR，EBR，DBR，OBR各是什么
- 计算机的控制权交接：
    - **BIOS**是位于主板上的一个小程序，在ROM上，其主要作用是简单的检测与初始化工作。
    - **MBR**，为了BIOS可以方便的将控制权交给MBR，MBR处于固定的位置，也就是硬盘的最开始扇区，存在于0盘0道1扇区。MBR分为：
        - 446字节的引导程序以及参数
        - 64字节的分区表
        - 2字节的结束标记0x55和0xaa
    BIOS会将0盘0道1扇区的MBR引导程序加载到0x7c00，然后跳过去执行，这样BIOS就把处理器使用权交给MBR了。
    - 之后寻找分区表中设置了活动标记为0x80的表项，为0x80说明该分区有引导程序。那么这个属于os的**次引导程序/加载器**会完成os的自举，内核加载器也是处在各分区的最开始扇区，这里存放的是**内核加载器**，这个引导程序(内核加载器)成为os的引导记录OBR(OS Boot Record)。那么在OBR的开始3个字节存放了跳转指令，故在MBR找到活动分区之后，就跳到OBR的引导扇区起始处，该起始处的跳转指令马上将处理器带入OS引导程序。那么之后便是内核的处理指令了
- DBR是DOS Boot Record，那么现在的OBR大多数遗留DBR的
- `EBR?`
# 一 部署工作环境
## 1.1 工欲善其事必先利其器
## 1.2 我们需要哪些编译器
- 这个OS采用C语言与汇编语言编写，那么C语言编译器采用**gcc**，汇编编译器采用nasm。一定要使用汇编语言，是因为高级语言**无法修改寄存器**。
## 1.3 操作系统的宿主环境
- `虚拟机：`虚拟机就是用软件来模拟硬件，虚拟机只是一个普通进程，该进程模拟了硬件资源，在虚拟机中运行的程序其所做出的任何行为都先被虚拟机检查，由虚拟机分析后，代为象操作系统申请。虚拟机在宿主机上只是一个**进程**
- `bochs配置：`[林夕的文章](https://blog.csdn.net/qq_45923646/article/details/120156421)，[设置可以输入中文的vscode](https://blog.csdn.net/u011504963/article/details/121231880)，[ubuntu20.04中文输入法](https://zhuanlan.zhihu.com/p/529892064)
# 二 编写MBR主引导记录，让我们开始掌权
## 2.1 计算机的启动过程
> CPU的硬件电路被设计成只能运行处于内存中的程序，
- `载入内存：`
    - 程序被加载器（软件或者硬件，本质上就是一堆函数组成的模块）加载到内存的某个区域
    - CPU的cs：ip寄存器被指向这个程序的起始地址
- 按下主机的power键之后，第一运行的软件BIOS，那么需要思考：
    - 它被谁加载
    - 它被加载到哪里
    - 它的cs：ip是谁来更改的
## 2.2 软件接力第一棒，BIOS
- `实模式：`Intel8086中有20位地址线，
    - 最后64KB是BIOS，BIOS的主要作用是**检测和初始化硬件**，硬件提供了一些初始化的功能调用，BIOS直接调用就好啦，BIOS还初始化了**中断向量表**，这样一来，就可以通过**int中断号**控制硬件，BIOS做的这些功能就是对IO的操作，但是由于在实模式下的64KB大小，不需要实现所有的硬件操作，保证计算机的**基本**硬件操作即可。
    - 前640KB是DRAM，也就是**内存**DRAM的动态性在于其集成度高，一个bit位需要8个电容，所以容易漏电，需要定时充电
- `BIOS的唤醒：`在开机的一开始，CS：IP被设置为0xF000：0xFFF0，这里便是BIOS的起始地址，这里是一条跳转指令，跳转至0xFE05B，之后BIOS开始检查内存，显卡等，当检测通过之后，之后初始化好硬件，开始在0x000～0x3FF之间建立数据结构，中断向量表IVT并填写中断例程。
- `MBR:`，一个OS的MBR从相应**分区**的0号盘0道1扇区，这种是CHS(Cylinder/Header/Sector)方式，扇区编号是从1开始的，在扇区最后两个字节是**0x55,0xaa**,通过这个魔数，BIOS断定这是MBR，在BIOS创建完IVT之后，那么会将磁盘上的MBR程序加载到物理地址0x7c00处，之后跳转到此处（此处的跳转采用的是jmp 0：0x7c00，**直接绝对远转移**），继续执行，MBR的作用一般是加载**boot loader**,也就是前446字节的主要作用是检查分区表是否正确且在系统硬件完成自检之后将控制权交给硬盘上的引导程序(比如GUN GRUB)，它不属于任何一个**OS**，且整个磁盘上只有一个。一般各分区最开始的扇区存放的是OS的引导程序——内核加载器
## 2.3 让MBR先飞一会儿
- `section:`如果在section处添加了`vstart`关键字，可以影响编译器对于地址的安排，如过该section用了vstart=xxxx修饰，那么$$的值就是`虚拟起始地址`xxxx?想要获得section在文件中的真实偏移量应该通过`section.节名.start`的方式？
- `bin与elf/pe等的区别：`bin文件是存二进制，CPU可以直接运行，而pe/elf等中包含程序的内存布局，位置等信息，这是给OS的程序`加载器`用的
# 三 完善MBR
## 3.1 地址，section，vstart浅尝辄止
- `vstart：`vstart=xxxx 与 org xxxx实现的是同一功能，都是在为之后的重定位做准备，使得编译器可以做程序`编址`,也就是说在使用vstart=xxxx修饰section之后，会有`加载器程序`将这个section加载到物理地址xxxx处
## 3.2 CPU的实模式
- `CPU工作原理：`控制单元通过PC地址，将指令送至指令寄存器IR，由指令译码器ID检查指令操作数与操作码，之后去取操作数，之后操作控制器OC去给运算单元发送指令。
- `实模式:`实模式是指intel 8086 CPU的寻址模式，寄存器大小，指令用法等。实模式的`实`体现在程序中用到的地址都是真实的物理地址，且不支持`多任务`，没有`特权级`，所以甚至可以修改OS的内存镜像，`段基址：段内偏移`产生的逻辑地址就是物理地址。
- `实模式下CPU内存寻址方式：`除了可以使用ss：sp的方式pop与push访问`栈`，还可以使用ss：bp的方式，比如在`栈中保存局部变量与函数参数，需要使用bp寄存器访问`，CPU的寻址方式看上去很死板，原因是一种寻址方式对呀一种电路实现，增加一种寻址方式，会增加硬件电路的复杂性，所以寻址方式有限。
- `实模式下的ret：`不能往IP寄存器中直接赋值。可以用一些特殊指令，例如call指令，要压入返回地址，进入中断，要压入代码段寄存器CS，指令寄存器IP，状态寄存器flags，除此之外还要考虑特权级，若特权级有变化，还要压入段寄存器SS和栈顶指针寄存器SP。在调用`call`指令，需要将返回地址(下一条指令的地址)保存在栈中，，在x86中，具体保存IP部分还是CS和IP都保存，要看目标函数的段基址是否和当前段基址一致，也就是说是否跨段。并且call指令并不会使用这个返回地址，ret/retf才会去使用这个返回地址。ret只会去将栈顶2个字节数据赋值给IP寄存器，而retf(return far)会将栈顶4个字节的数据赋值给CS和IP。call需要与ret/retf配合使用，根据call的种类来选择ret/retf。call/ret配合属于近调用/近返回，而call far与retf属于远调用/远返回
- `实模式下的call：`call指令属于执行一段代码后需要返回的场景，jmp指令则是执行完一段代码不需要返回的场景，适合`交接`，比如BIOS将接力棒交给MBR。16位实模式的call指令：
    - `相对近调用`，`call near + 立即数`默认是2字节，near的作用类似word，dword，所以near可以省略，其中立即数是当前call指令与函数地址之间的差值，所以是`相对`，`call + 立即数`默认是相对近调用,并且这个立即数在程序中是绝对地址，但是机器码是相对地址
    - `间接绝对近调用：``间接`指的是目标函数地址不是以立即数的方式给出，地址要么在寄存器中，要么在内存中，`绝对`指的是目标函数的地址是绝对地址，只要是在内存/寄存器中的地址，那么就是间接绝对调用
    - `直接绝对远调用：``直接`指的就是不经过寄存器或内存，操作数直接以`立即数`的方式给出，`远`指的是要跨段，目标函数与当前指令不在一个段中，一般形式是`call far 段基址(立即数):段内偏移地址(立即数)`
    - `间接绝对调用：`不支持寄存器寻址，只支持内存寻址
- `数据类型伪指令：`byte，word，dword，qword，他们用在操作数前面，相当于做数据类型强制转换，无论操作数是立即数，寄存器，还是内存都可以使用数据类型伪指令，`near`的意思同数据类型伪指令word一样，是指在内存地址取值字节内容，或者将操作数强制转换为2字节，`near，short，far`这些用在调用或转移中的修饰符，其意义就是数据类型转换。每种数据类型大小不同，即表示数的范围不同，用不同的范围来表示不同的调用或转移范围
- `实模式下的jmp：`无条件跳转，是指直接改变CPU的航向，16位模式下的jmp
    - `相对短转移：``jmp short 立即数地址`，相对短转移的转移范围只有1个字节，即-128～127
    - `相对近转移：``jmp near 立即数地址`，相对近转移的转移范围有章个字节，也即-32768～32767，如果在`jmp`之后没有写near/short，汇编器会自己判断立即数大小
    - `间接绝对近转移：`目的地址是绝对地址，并且存在内存或者寄存器中
    - `直接绝对远转移：``直接`表示不仅仅是立即数，CPU可以直接拿来用，
    - `间接绝对远转移：`将段基址和段偏移两个数放在内存中，
- `标志寄存器flags：`16位寄存器，其中存储的是上一条指令执行的结果的`特征标志`，
- `有条件转移：`目标地址只能是`段内地址`，在保护模式下，寄存器已经是32位了，编译器所以不区分转移方式了。
## 3.3 让我们直接对显示器说些什么吧
- `CPU与外设交互，IO接口：`CPU系统总线上传送的都是并行数据，而外设可是并行，串行都有。所以需要在CPU和外设之间加一层接口——`IO接口`，它可以是个电路板，芯片，或者插槽它的作用就是在CPU和外设之间相互协调转换。IO接口由硬件与软件构成，软件部分是用来控制接口电路的驱动程序以及完成内部数据传输所需要的程序，通过端口的`in/out指令`来实现选择IO接口上的功能，工作模式。I/O接口的功能有：
    - 设置数据缓冲，解决CPU与外设的速度不匹配
    - 设置信号电平转换电路
    - 设置数据格式转换，外设多种多样，所以输出的信息也可能是数字信号，模拟信号等，还涉及格式字长等问题
    - 设置时序控制电路来同步CPU和外设
    - 提供地址译码，一个IO接口中有多个`端口（也就是寄存器）`，一般通过`内存映射IO`实现，这样就可以复用`mov指令`，但是如果是独立编址，那么就是使用`in/out指令`
- `南桥芯片：`是慢速设备的IO接口的输入输出控制中心，是用来仲裁IO接口的竞争，PCI Express总线是串行设备
- `北桥芯片：`南桥芯片与其连接，另外北桥芯片是快速设备IO接口的输入输出控制中心
- `显卡：`显卡有自己的BIOS，磁盘也有自己的BIOS，BIOS中储存了显示卡的硬件控制程序和相关信息。可以说BIOS是显示卡的“神经中枢”。`GPU`是显卡的CPU。在显卡的`文本模式`中，其显存的位置是0xB8000到0xBFFFF，那么每屏幕可以显示2000个字，就是可以显示8屏数据，所以可以实现其tty的切换，一个文本需要占用2个字节，一个字节是ASCII码，另一个是显示字的属性
- `段超越/跨越前缀：`间接寻址时，在`[]`中显示的指出段基址寄存器，比如`[gs:0x00]`，这叫做段超越前缀
## 3.4 bochs调试方法
- 
## 3.5 硬盘介绍
- `集成电路设备(IDE):`因为显示器太大，显卡和显示器是分开的，`硬盘控制器和硬盘`一开始也是分开的，后来整合在一起了，`ATA`是全球硬盘标准
- `硬盘控制器的端口：`是针对4块硬盘的，通过primary/secondary通道(一个通道上有master/slave两块磁盘)的映射IO地址不同以及device寄存器的某一位来区分
- `数据传送的方法：`
    - `无条件传送`，寄存器和内存采用这种方式
    - `查询传送`
    - `中断传送`
    - `直接存储器存取(DMA)`，中断传送方式中，需要数据就绪之后，由`CPU`执行传输指令，来将缓存中的数据送入内存中，那么在DMA中，DMA控制器可以帮助完成这一部分的工作。
    - `IO处理器传送`，在DMA中，数据交换，检验，组合仍旧由CPU完成，那么在IO处理器传送方式中，这些都由IO处理器的硬件完成，这个处理器可以看做一个只处理IO指令的CPU
## 3.6 让MBR使用硬盘
- `MBR加载loader`MBR需要将loader从磁盘上加载到内存中，完成这一次启动接力，MBR位于磁盘的第0扇区(LBA编址)，那么loader位于第2个扇区，MBR将其从磁盘读出，放到`实模式下内存布局`中的`可用布局`处
# 四 保护模式入门
## 4.1 保护模式概述
- `实模式的缺陷：`
    - 安全性差，操作系统的可以被随意更改
        - 实模式下操作系统和用户程序处于同一特权级
        - 用户程序使用真实的物理地址
        - 用户可以随意更改段基址，
    - 使用困难
        - 使用超过64KB的内存区域时，要切换段基址
        - 一次只可以运行一个程序
        - 只有20根地址线，内存最多1MB，不太够用
- `虚拟地址：`在保护模式下，程序访问的是虚拟地址，需要通过硬件的MMU部件，并由OS提供页表，转换为物理地址
- `保护模式：`32位CPU为了兼容16位CPU，实模式下，CPU运行环境是16位，保护模式下，CPU运行环境是32位，所以`实模式`是指32位CPU运行在16位的状态下
## 4.2 初见保护模式
- `保护模式下的段基址寄存器：`还是16位，其中存的是`选择子`，用来索引全局描述符表中的表项，将一个段的相关信息存储到一个全局数据结构中——`全局描述符表`，每个表项(段描述符)64字节，由`GDTR寄存器`指向它。
    - `段描述符`是在内存中，CPU取内存比较慢
    - `段描述符`格式很怪，一个数据要放在三个地方存，所以CPU拼凑它们，需要花费时间。`段描述符缓冲寄存器`可以缓解这个问题，CPU每次将获取到的内存段信息，整理好之后存到该寄存器中，那么下次就可以直接读取了。在`实模式`下，可以将段基址右移4位之后的数值存入`段描述符缓冲寄存器`中，
- `CPU三种模式：`实模式，虚拟8086模式，保护模式
- 由于编译器难以判断代码处在什么模式，所以需要使用`bits伪指令`明确指出运行模式，进入保护模式有三个步骤，这三个步骤可以不顺序，也可以不连续：
    - 打开A20 
    - 加载gdt
    - 将cr0的pe位置1
- `反转前缀：`
    - `操作数反转前缀0x66：`如果16位实模式下要使用32位保护模式下的操作数大小，需要在指令前面添加指令前缀0x66,将当前模式临时改变成另一模式，这种转换只是临时的，只在当前指令有效，32位转换为16位也是一样，0x66是转换为相反的运行模式。
    - `寻址方式反转前缀0x67：`如果16位实模式转换为32位保护模式，比如在16位实模式下使用`mov word [eax], 0x1234`,那么其机器码会是`67C7003412`
- `指令扩展：`intel指令需要支持不同位数的操作数，比如`add al, cl`是8位，`add ax，cx`是16位，`add eax，ecx`是32位
## 4.3 全局描述符表
- `全局描述符表：`内存段在保护模式下，需要很多信息描述，所以需要一个表来记录这些内存段的信息，`全局描述符表`是保护模式下内存段的登记表，在保护模式下，需要存储关于段的更多安全信息，单个寄存器不足以存储段的安全信息，所以需要在一张表中存储，其中属性包括
    - 在实模式下，用户程序可以破坏存储代码的内存区域，所以要添加内存段类型属性来阻止这种行为，通过`段描述符的S字段`来决定该段是`系统段`还是`数据段(非系统段)`，凡是软件需要的东西都是数据(os也是软件)，非系统段又分为`代码段`与`数据段`。各种`门`结构是`系统段`，也就是硬件系统需要的结构，如调用门，任务门。门的意思就是入口，它通往一段程序，
    - 实模式下，用户程序和操作系统是同一级别，所以需要添加个特权属性来区分用户程序和操作系统的地位
    - 一些访问内存段的必要属性
    - 为了限制程序访问内存的范围，还要对段大小进行约束，
- `全局描述符表GDT，局部描述符表LDT及选择子：`
    - 需要使用`lgdt指令`来初始化GDTR寄存器，这个指令可以在实模式，也可以在保护模式下执行，lgdt指令格式是`lgdt48位内存数据`
    - `选择子：`实模式下，段寄存器存的都是段基地址，也即内存段的起始地址，那么在保护模式下，段寄存器(比如CS，DS，ES，FS，GS，SS)中存储的是`选择子selector`，通过它来从`GDT`中索引段描述符。选择子中的第0～1位存储RPL，也即请求特权级，第2位是TI位，用来指示选择子实在GDT中，还是在LDT中索引描述符。选择子的高13位，用来索引`段描述符`，在保护模式下，段描述符中的段基址不需要在去左移4位，由于地址线和寄存器都是32位
    - `LDT局部描述符表：`CPU厂商在为硬件一级原生鸡翅多任务而创建的表，一个任务对应一个LDT，CPU厂商建议每个任务的私有内存段都应该放到自己的的段描述符表中，也即每个任务都由自己的段描述符表，任务切换时，也要切换相应的任务的LDT，LDT也位于内存中，其地址需要先被加载到某个寄存器后，CPU才能使用LDT，这个寄存器就是LDTR，也有专门的指令`lldt`来加载任务的私有内存段，每次切换任务时，都需要使用lldt指令从新加载任务的私有内存段，使用`lldt 16位寄存器/16位内存`，LDT是需要在GDT中先注册，
    - 在段描述符中，由8-11位的type和第12位的S来决定段的总类，虽然在`全局描述符表`中存在很多系统段，但是不是所有的全局描述表都存在其中，比如`中断门，陷阱门，任务门等`都是在中断描述符表中，
- `A20地址线：`由于80286有24根地址线，那么在访问0x100000～0x10FFEF之间的内存时，为来兼容性，需要保证实模式下，只使用20位地址线，在`保护模式`下，需要打开A20Gate，也就是将端口0x92的第1位置1。IBM在键盘控制器上的一些输出线来控制第21根地址线(A20)的有效性，故被称为A20Gate：
    - 当A20Gate打开时，当访问到0x100000～0x10FFEF之间的地址时，CPU将真正访问这块物理内存
    - 当A20Gate被禁止，当访问到0x100000～0x10FFEF之间的地址时，CPU将采取8086/8088地址绕回
- `保护模式的开关，CR0寄存器的PE位：`控制寄存器CRx系列，CR0寄存器的第0位，PE(Protection Enable),PE为0表示在实模式下运行，PE为1表示在保护模式下运行，
- `关于从x86实模式到保护模式的关键一跳的指令连续执行问题?关键一跳的作用存疑`:>段寄存器后面都有隐藏的高速缓冲寄存器，当cs寄存器值被更新时，这个高速缓冲寄存器的值会根据当时的寻址方式更新，比如实模式下就是cs<<4后放入高速缓冲寄存器，等需要取指令的时候就直接取高速缓冲寄存器的值与eip相加即可，并不会真的再去cs段寄存器找这个值然后做像保护模式下的寻址方式那样推导。这样就解释了上面的情况，虽然寻址方式改变了，但是cs段寄存器的值没变，高速缓冲寄存器的值就不会变，基址仍然是实模式时的值，从而实际上计算出来的还是实模式的地址，保证了指令流的持续执行。内核在等到切换准备就绪的时候就会执行一个长跳转指令来刷新cs段寄存器的值，从而真的跳转导保护模式下了。
# 参考
- [《操作系统真象还原》，作者郑钢](https://book.douban.com/subject/26745156/)
