>互联网冲浪多年，苦苦寻找捷径，想要学会编程，到头来发现，完全没有捷径呢，学编译原理，需要学会写编译器，学os，需要写一个kernel，学图形学，需要实现renderer，学网络，需要实现网络库，webserver。code，code，code！！！
# 零 一些你可能正在迷惑的问题
## 0.9 物理地址，逻辑地址，有效地址，线性地址，虚拟地址的区别
- `物理地址：`物理内存的真实地址，CPU最终需要以物理地址去访问内存。
- `逻辑地址/有效地址：`无论是在实模式还是在保护模式下，段内偏移地址又称为有效地址，也成为**逻辑地址**。
- `线性地址/虚拟地址：`它们不是真实的地址，它们用来描述程序或任务的地址空间。
## 0.10 是什么是段重叠
- `段重叠：`![](picture/%E6%AE%B5%E9%87%8D%E5%8F%A0.jpg)
## 0.11 什么是平坦模式？
- `平坦模式：`相对于多段模型而言，可以理解为**单段模式**，不需要切换**段基址**，以及额外打开**A20地址线**？
## 0.12 cs,ds 这类sreg段寄存器，位宽是多少
- CS, DS, ES, FS, GS, SS段寄存器，在**实模式**下，是**段基址**，而在**保护模式**下，是**段选择子（Selector）**，也就是通过选择子，可以在GDT中找到相应的段描述符，在该描述符中记录了段的起始，大小等信息，于是便得到了段基址。在32位CPU中，段寄存器的位宽都是16位。
## 0.13 什么是工程，什么是协议
- `工程：`就是为了完成软件编写所涉及的全部相关文件。
- `协议：`一种大家都共同遵守的规约，主要用来实现通信，共享，协作；起初是为了避免大家各干各的，无法彼此调用对方成果的情况，从而给大家统一一种接口，一组数据调用或者分析的约定。
## 0.14 为什么Linux系统下的英勇程序不饿能在Windows系统下运行
- 主要是因为Linux的可执行文件是ELF，而Windows是PE；它们的**API**也不一样，Linux的API是系统调用，采用int 0x80中断实现，而Windows的API是在DLL中，**DLL不是可执行文件，不能够单独使用**；除此之外，还有编译器，标准库等的不同。
## 0.15 局部变量和函数参数为什么要放在栈中
- 由于这些变量只由这些函数自己使用，这是**局部性原理**；并且在函数调用之前，并不知道该函数需要使用多少内存存储这些变量。
## 0.16 为什么说汇编语言比C语言更快
- 汇编并没有比C语言运行的更快，而是生成的**指令数更少**；而C语言为了程序员的便利，额外做了大量的工作，所以会加入额外代码。
## 0.17 先有的语言，还是先有的编译器，第一个编译器怎么产生的
- 编译器可以编译出新的编译器，这种自己创造自己的现象称为**自举**。
- 用旧的编译器去**训练编译**新的编译器
## 0.18 编译性程序与解释型程序的区别
- 解释型语言，也叫脚本语言，它们都是**脚本解释器**的输入文件，脚本解释器实时分析这个脚本。**浏览器**之于JS，就如**PHP解释器**之于PHP
- **编译型语言**会生成二进制文件
## 0.19 什么是大端字节序，小段字节序
- `小端序：`低字节放在内存低地址，高字节放在内存高地址。**优势在于**强制转换数据类型时不需要要调整字节。**bmp图片**采用小端序。
- `大端序：`与小端序相反。**优势是**符号位易取出。**jepg图片**采用大端序。**网络传输采用大端序，所以在x86架构上的程序发送网络数据时，需要转换字节序**
## 0.20 BIOS中断，DOS中断，Linux中断的区别？
- `BIOS中断：`计算机启动之初，BIOS在中断向量表（IVT）中建立中断例程，它从物理内存0x0000处初始化并在中断向量表中添加各种例程。BIOS中断调用的主要功能时提供了硬件的访问方法，使得访问硬件更加简单，虽然通过in/out指令也可以来读写外设的端口
- `DOS中断：`其也是在**实模式**下运行，其建立的中断调用也是在中断向量表（IVT），占用**0x21中断号**
- `Linux中断：`处于**保护模式**，通过**int 0x80指令**进入一个中断程序，在根据eax寄存器的值来调用不同的子功能函数，不过这时访问的时**中断描述符表（IDT）**，也就是说在**保护模式下执行int指令会去访问IDT，而实模式下时IVT**
## 0.21 Section和Segment的区别
- `section：`编译器将高级语言编译汇编，其中汇编器将汇编语言中逻辑划分指令或数据区域，**section**处于**目标文件**。
- `segment：`**链接器**将各个seciton根据器属性，将多个seciton合并到一个segment，所以segment处于**可执行文件**中
- 在汇编代码中如果以标准节名定义seciton，比如**.bss**，编译器会将其放到**.bss**中
## 0.22 什么是魔数
- 比如，在ELF文件的开头，存在着这样的数字![](picture/ELF%E9%AD%94%E6%95%B0.jpg),那么**ELF解析器(通常是程序加载器)**用它来检验文件的类型是否是elf。
## 0.23 操作系统是如何识别文件系统的
- 通过检查文件系统分区的第1个扇区便是超级块的起始扇区，其中便纪录了文件系统的**魔数**
## 0.24 如何控制CPU的下一条指令
- 在x86体系结构中，PC指的是一组寄存器，段寄存器CS和指令寄存器IP。不能够使用`mov`去改变CS:IP，但是可以用`jmp，call，int，ret`去改变，它们在硬件层面实现了原子操作。PC是获取下一条指令的方法形式，在不同的体系结构的CPU中有不同的实现方法。
## 0.25 指令集，体系结构，微架构，编程语言
- `指令集：`指令集是具体的一套指令编码，微架构是指令集的物理实现方式。对于x86这样的指令集，它本身是RISC指令，但是由于效率过低，最终其内部实现采取了RISC内核，即一条CISC指令在译码时，分解成多条RISC指令。**CPU与指令集对应，一种CPU只能识别一种指令集**
- 编程语言，底层需要运行在CPU之上，所以必须要编译器按照该CPU的指令集，翻译存储符合该CPU的指令。
- `交叉编译：`就是指在A平台上运行的编译器，编译处符合B平台CPU指令集的程序，编译处的程序直接能在B平台上运行。这里的平台就是指CPU指令体系结构。
## 0.26 库函数时用户进程与内核的桥梁
- **库函数**帮助写下了调用系统调用的代码
- **extern关键字：**它的作用仅仅只是告诉编译器，该关键字修饰的变量，应该在**链接**的时候去找**定义**![](picture/extern%E5%92%8Cinclude%E5%85%B3%E9%94%AE%E5%AD%97.jpg)
- `运行时库：`是程序在运行时所需要的库，该库是由众多可复用的函数文件组成，由编译器提供。在Linux环境下，gcc可以提供C语言的运行时。
- 尽管系统调用封装在库函数中，但用户程序可以直接调用“系统调用”，不过用函数会比较高效。
## 0.27 转移字符和ASCII码
- `转义字符：`在ASCII码中，如何将不可见的字符**写**出来，使用`\`这个转义字符，比如`\n`表示换行符
## 0.28 MBR，EBR，DBR，OBR各是什么
- 计算机的控制权交接：
    - **BIOS**是位于主板上的一个小程序，在ROM上，其主要作用是简单的检测与初始化工作。
    - **MBR**，为了BIOS可以方便的将控制权交给MBR，MBR处于固定的位置，也就是硬盘的最开始扇区，存在于0盘0道1扇区。MBR分为：
        - 446字节的引导程序以及参数
        - 64字节的分区表
        - 2字节的结束标记0x55和0xaa
    BIOS会将0盘0道1扇区的MBR引导程序加载到0x7c00，然后跳过去执行，这样BIOS就把处理器使用权交给MBR了。
    - 之后寻找分区表中设置了活动标记为0x80的表项，为0x80说明该分区有引导程序。那么这个属于os的**次引导程序/加载器**会完成os的自举，内核加载器也是处在各分区的最开始扇区，这里存放的是**内核加载器**，这个引导程序(内核加载器)成为os的引导记录OBR(OS Boot Record)。那么在OBR的开始3个字节存放了跳转指令，故在MBR找到活动分区之后，就跳到OBR的引导扇区起始处，该起始处的跳转指令马上将处理器带入OS引导程序。那么之后便是内核的处理指令了
- DBR是DOS Boot Record，那么现在的OBR大多数遗留DBR的
- `EBR?`
# 一 部署工作环境
## 1.1 工欲善其事必先利其器
## 1.2 我们需要哪些编译器
- 这个OS采用C语言与汇编语言编写，那么C语言编译器采用**gcc**，汇编编译器采用nasm。一定要使用汇编语言，是因为高级语言**无法修改寄存器**。
## 1.3 操作系统的宿主环境
- `虚拟机：`虚拟机就是用软件来模拟硬件，虚拟机只是一个普通进程，该进程模拟了硬件资源，在虚拟机中运行的程序其所做出的任何行为都先被虚拟机检查，由虚拟机分析后，代为象操作系统申请。虚拟机在宿主机上只是一个**进程**
- `bochs配置：`[林夕的文章](https://blog.csdn.net/qq_45923646/article/details/120156421)
# 二 编写MBR主引导记录，让我们开始掌权
## 2.1 计算机的启动过程
> CPU的硬件电路被设计成只能运行处于内存中的程序，
- `载入内存：`
    - 程序被加载器（软件或者硬件，本质上就是一堆函数组成的模块）加载到内存的某个区域
    - CPU的cs：ip寄存器被指向这个程序的起始地址
- 按下主机的power键之后，第一运行的软件BIOS，那么需要思考：
    - 它被谁加载
    - 它被加载到哪里
    - 它的cs：ip是谁来更改的
## 2.2 软件接力第一棒，BIOS
- `实模式：`Intel8086中有20位地址线，
    - 最后64KB是BIOS，BIOS的主要作用是**检测和初始化硬件**，硬件提供了一些初始化的功能调用，BIOS直接调用就好啦，BIOS还初始化了**中断向量表**，这样一来，就可以通过**int中断号**控制硬件，BIOS做的这些功能就是对IO的操作，但是由于在实模式下的64KB大小，不需要实现所有的硬件操作，保证计算机的**基本**硬件操作即可。
    - 前640KB是DRAM，也就是**内存**DRAM的动态性在于其集成度高，一个bit位需要8个电容，所以容易漏电，需要定时充电
- `BIOS的唤醒：`在开机的一开始，CS：IP被设置为0xF000：0xFFF0，这里便是BIOS的起始地址，这里是一条跳转指令，跳转至0xFE05B，之后BIOS开始检查内存，显卡等，当检测通过之后，之后初始化好硬件，开始在0x000～0x3FF之间建立数据结构，中断向量表IVT并填写中断例程。
- `MBR:`，一个OS的MBR从相应**分区**的0号盘0道1扇区，这种是CHS(Cylinder/Header/Sector)方式，扇区编号是从1开始的，在扇区最后两个字节是**0x55,0xaa**,通过这个魔数，BIOS断定这是MBR，在BIOS创建完IVT之后，那么会将磁盘上的MBR程序加载到物理地址0x7c00处，之后跳转到此处（此处的跳转采用的是jmp 0：0x7c00，**直接绝对远转移**），继续执行，MBR的作用一般是加载**boot loader**,也就是前446字节的主要作用是检查分区表是否正确且在系统硬件完成自检之后将控制权交给硬盘上的引导程序(比如GUN GRUB)，它不属于任何一个**OS**，且整个磁盘上只有一个。一般各分区最开始的扇区存放的是OS的引导程序——内核加载器
## 2.3 让MBR先飞一会儿
- `section:`如果在section处添加了`vstart`关键字，可以影响编译器对于地址的安排，如过该section用了vstart=xxxx修饰，那么$$的值就是`虚拟起始地址`xxxx?想要获得section在文件中的真实偏移量应该通过`section.节名.start`的方式？
- `bin与elf/pe等的区别：`bin文件是存二进制，CPU可以直接运行，而pe/elf等中包含程序的内存布局，位置等信息，这是给OS的程序`加载器`用的
# 三 完善MBR
## 3.1 地址，section，vstart浅尝辄止
- `vstart：`vstart=xxxx 与 org xxxx实现的是同一功能，都是在为之后的重定位做准备，使得编译器可以做程序`编址`,也就是说在使用vstart=xxxx修饰section之后，会有`加载器程序`将这个section加载到物理地址xxxx处
## 3.2 CPU的实模式
- `CPU工作原理：`控制单元通过PC地址，将指令送至指令寄存器IR，由指令译码器ID检查指令操作数与操作码，之后去取操作数，之后操作控制器OC去给运算单元发送指令。
- `实模式:`实模式是指intel 8086 CPU的寻址模式，寄存器大小，指令用法等。实模式的`实`体现在程序中用到的地址都是真实的物理地址，`段基址：段内偏移`产生的逻辑地址就是物理地址。
- `实模式下CPU内存寻址方式：`除了可以使用ss：sp的方式pop与push访问`栈`，还可以使用ss：bp的方式，比如在`栈中保存局部变量与函数参数，需要使用bp寄存器访问`，CPU的寻址方式看上去很死板，原因是一种寻址方式对呀一种电路实现，增加一种寻址方式，会增加硬件电路的复杂性，所以寻址方式有限。
- `实模式下的ret：`不能往IP寄存器中直接赋值。可以用一些特殊指令，例如call指令，要压入返回地址，进入中断，要压入代码段寄存器CS，指令寄存器IP，状态寄存器flags，除此之外还要考虑特权级，若特权级有变化，还要压入段寄存器SS和栈顶指针寄存器SP。在调用`call`指令，需要将返回地址(下一条指令的地址)保存在栈中，，在x86中，具体保存IP部分还是CS和IP都保存，要看目标函数的段基址是否和当前段基址一致，也就是说是否跨段。并且call指令并不会使用这个返回地址，ret/retf才会去使用这个返回地址。ret只会去将栈顶2个字节数据赋值给IP寄存器，而retf(return far)会将栈顶4个字节的数据赋值给CS和IP。call需要与ret/retf配合使用，根据call的种类来选择ret/retf。call/ret配合属于近调用/近返回，而call far与retf属于远调用/远返回
- `实模式下的call：`call指令属于执行一段代码后需要返回的场景，jmp指令则是执行完一段代码不需要返回的场景，适合`交接`，比如BIOS将接力棒交给MBR。16位实模式的call指令：
    - `相对近调用`，`call near + 立即数`默认是2字节，near的作用类似word，dword，所以near可以省略，其中立即数是当前call指令与函数地址之间的差值，所以是`相对`，`call + 立即数`默认是相对近调用,并且这个立即数在程序中是绝对地址，但是机器码是相对地址
    - `间接绝对近调用：``间接`指的是目标函数地址不是以立即数的方式给出，地址要么在寄存器中，要么在内存中，`绝对`指的是目标函数的地址是绝对地址，只要是在内存/寄存器中的地址，那么就是间接绝对调用
    - `直接绝对远调用：``直接`指的就是不经过寄存器或内存，操作数直接以`立即数`的方式给出，`远`指的是要跨段，目标函数与当前指令不在一个段中，一般形式是`call far 段基址(立即数):段内偏移地址(立即数)`
    - `间接绝对调用：`不支持寄存器寻址，只支持内存寻址
- `数据类型伪指令：`byte，word，dword，qword，他们用在操作数前面，相当于做数据类型强制转换，无论操作数是立即数，寄存器，还是内存都可以使用数据类型伪指令，`near`的意思同数据类型伪指令word一样，是指在内存地址取值字节内容，或者将操作数强制转换为2字节，`near，short，far`这些用在调用或转移中的修饰符，其意义就是数据类型转换。每种数据类型大小不同，即表示数的范围不同，用不同的范围来表示不同的调用或转移范围
- `实模式下的jmp：`无条件跳转，是指直接改变CPU的航向，16位模式下的jmp
    - `相对短转移：``jmp short 立即数地址`，相对短转移的转移范围只有1个字节，即-128～127
    - `相对近转移：``jmp near 立即数地址`，相对近转移的转移范围有章个字节，也即-32768～32767，如果在`jmp`之后没有写near/short，汇编器会自己判断立即数大小
    - `间接绝对近转移：`目的地址是绝对地址，并且存在内存或者寄存器中
    - `直接绝对远转移：``直接`表示不仅仅是立即数，CPU可以直接拿来用，
    - `间接绝对远转移：`将段基址和段偏移两个数放在内存中，
# 参考
- [《操作系统真象还原》，作者郑钢](https://book.douban.com/subject/26745156/)
