>互联网冲浪多年，苦苦寻找捷径，想要学会编程，到头来发现，完全没有捷径呢，学编译原理，需要学会写编译器，学os，需要写一个kernel，学图形学，需要实现renderer，学网络，需要实现网络库，webserver。code，code，code！！！
# 零 一些你可能正在迷惑的问题
## 0.9 物理地址，逻辑地址，有效地址，线性地址，虚拟地址的区别
- `物理地址：`物理内存的真实地址，CPU最终需要以物理地址去访问内存。
- `逻辑地址/有效地址：`无论是在实模式还是在保护模式下，段内偏移地址又称为有效地址，也成为**逻辑地址**。
- `线性地址/虚拟地址：`它们不是真实的地址，它们用来描述程序或任务的地址空间。
## 0.10 是什么是段重叠
- `段重叠：`![](picture/%E6%AE%B5%E9%87%8D%E5%8F%A0.jpg)
## 0.11 什么是平坦模式？
- `平坦模式：`相对于多段模型而言，可以理解为**单段模式**，不需要切换**段基址**，以及额外打开**A20地址线**？
## 0.12 cs,ds 这类sreg段寄存器，位宽是多少
- CS, DS, ES, FS, GS, SS段寄存器，在**实模式**下，是**段基址**，而在**保护模式**下，是**段选择子（Selector）**，也就是通过选择子，可以在GDT中找到相应的段描述符，在该描述符中记录了段的起始，大小等信息，于是便得到了段基址。在32位CPU中，段寄存器的位宽都是16位。
## 0.13 什么是工程，什么是协议
- `工程：`就是为了完成软件编写所涉及的全部相关文件。
- `协议：`一种大家都共同遵守的规约，主要用来实现通信，共享，协作；起初是为了避免大家各干各的，无法彼此调用对方成果的情况，从而给大家统一一种接口，一组数据调用或者分析的约定。
## 0.14 为什么Linux系统下的英勇程序不饿能在Windows系统下运行
- 主要是因为Linux的可执行文件是ELF，而Windows是PE；它们的**API**也不一样，Linux的API是系统调用，采用int 0x80中断实现，而Windows的API是在DLL中，**DLL不是可执行文件，不能够单独使用**；除此之外，还有编译器，标准库等的不同。
## 0.15 局部变量和函数参数为什么要放在栈中
- 由于这些变量只由这些函数自己使用，这是**局部性原理**；并且在函数调用之前，并不知道该函数需要使用多少内存存储这些变量。
## 0.16 为什么说汇编语言比C语言更快
- 汇编并没有比C语言运行的更快，而是生成的**指令数更少**；而C语言为了程序员的便利，额外做了大量的工作，所以会加入额外代码。
## 0.17 先有的语言，还是先有的编译器，第一个编译器怎么产生的
- 编译器可以编译出新的编译器，这种自己创造自己的现象称为**自举**。
- 用旧的编译器去**训练编译**新的编译器
## 0.18 编译性程序与解释型程序的区别
- 解释型语言，也叫脚本语言，它们都是**脚本解释器**的输入文件，脚本解释器实时分析这个脚本。**浏览器**之于JS，就如**PHP解释器**之于PHP
- **编译型语言**会生成二进制文件
## 0.19 什么是大端字节序，小段字节序
- `小端序：`低字节放在内存低地址，高字节放在内存高地址。**优势在于**强制转换数据类型时不需要要调整字节。**bmp图片**采用小端序。
- `大端序：`与小端序相反。**优势是**符号位易取出。**jepg图片**采用大端序。**网络传输采用大端序，所以在x86架构上的程序发送网络数据时，需要转换字节序**
## 0.20 BIOS中断，DOS中断，Linux中断的区别？
- `BIOS中断：`计算机启动之初，BIOS在中断向量表（IVT）中建立中断例程，它从物理内存0x0000处初始化并在中断向量表中添加各种例程。BIOS中断调用的主要功能时提供了硬件的访问方法，使得访问硬件更加简单，虽然通过in/out指令也可以来读写外设的端口
- `DOS中断：`其也是在**实模式**下运行，其建立的中断调用也是在中断向量表（IVT），占用**0x21中断号**
- `Linux中断：`处于**保护模式**，通过**int 0x80指令**进入一个中断程序，在根据eax寄存器的值来调用不同的子功能函数，不过这时访问的时**中断描述符表（IDT）**，也就是说在**保护模式下执行int指令会去访问IDT，而实模式下时IVT**
## 0.21 Section和Segment的区别
- `section：`编译器将高级语言编译汇编，其中汇编器将汇编语言中逻辑划分指令或数据区域，**section**处于**目标文件**。
- `segment：`**链接器**将各个seciton根据器属性，将多个seciton合并到一个segment，所以segment处于**可执行文件**中
- 在汇编代码中如果以标准节名定义seciton，比如**.bss**，编译器会将其放到**.bss**中
## 0.22 什么是魔数
- 比如，在ELF文件的开头，存在着这样的数字![](picture/ELF%E9%AD%94%E6%95%B0.jpg),那么**ELF解析器(通常是程序加载器)**用它来检验文件的类型是否是elf。
## 0.23 操作系统是如何识别文件系统的
- 通过检查文件系统分区的第1个扇区便是超级块的起始扇区，其中便纪录了文件系统的**魔数**
## 0.24 如何控制CPU的下一条指令
- 在x86体系结构中，PC指的是一组寄存器，段寄存器CS和指令寄存器IP。不能够使用`mov`去改变CS:IP，但是可以用`jmp，call，int，ret`去改变，它们在硬件层面实现了原子操作。PC是获取下一条指令的方法形式，在不同的体系结构的CPU中有不同的实现方法。
## 0.25 指令集，体系结构，微架构，编程语言
- `指令集：`指令集是具体的一套指令编码，微架构是指令集的物理实现方式。对于x86这样的指令集，它本身是RISC指令，但是由于效率过低，最终其内部实现采取了RISC内核，即一条CISC指令在译码时，分解成多条RISC指令。**CPU与指令集对应，一种CPU只能识别一种指令集**
- 编程语言，底层需要运行在CPU之上，所以必须要编译器按照该CPU的指令集，翻译存储符合该CPU的指令。
- `交叉编译：`就是指在A平台上运行的编译器，编译处符合B平台CPU指令集的程序，编译处的程序直接能在B平台上运行。这里的平台就是指CPU指令体系结构。
## 0.26 库函数时用户进程与内核的桥梁
- **库函数**帮助写下了调用系统调用的代码
- **extern关键字：**它的作用仅仅只是告诉编译器，该关键字修饰的变量，应该在**链接**的时候去找**定义**![](picture/extern%E5%92%8Cinclude%E5%85%B3%E9%94%AE%E5%AD%97.jpg)
- `运行时库：`是程序在运行时所需要的库，该库是由众多可复用的函数文件组成，由编译器提供。在Linux环境下，gcc可以提供C语言的运行时。
- 尽管系统调用封装在库函数中，但用户程序可以直接调用“系统调用”，不过用函数会比较高效。
## 0.27 转移字符和ASCII码
- `转义字符：`在ASCII码中，如何将不可见的字符**写**出来，使用`\`这个转义字符，比如`\n`表示换行符
## 0.28 MBR，EBR，DBR，OBR各是什么
- 计算机的控制权交接：
    - **BIOS**是位于主板上的一个小程序，在ROM上，其主要作用是简单的检测与初始化工作。
    - **MBR**，为了BIOS可以方便的将控制权交给MBR，MBR处于固定的位置，也就是硬盘的最开始扇区，存在于0盘0道1扇区。MBR分为：
        - 446字节的引导程序以及参数
        - 64字节的分区表
        - 2字节的结束标记0x55和0xaa
    BIOS会将0盘0道1扇区的MBR引导程序加载到0x7c00，然后跳过去执行，这样BIOS就把处理器使用权交给MBR了。
    - 之后寻找分区表中设置了活动标记为0x80的表项，为0x80说明该分区有引导程序。那么这个属于os的**次引导程序/加载器**会完成os的自举，内核加载器也是处在各分区的最开始扇区，这里存放的是**内核加载器**，这个引导程序(内核加载器)成为os的引导记录OBR(OS Boot Record)。那么在OBR的开始3个字节存放了跳转指令，故在MBR找到活动分区之后，就跳到OBR的引导扇区起始处，该起始处的跳转指令马上将处理器带入OS引导程序。那么之后便是内核的处理指令了
- DBR是DOS Boot Record，那么现在的OBR大多数遗留DBR的
- `EBR?`
# 一 部署工作环境
## 1.1 工欲善其事必先利其器
## 1.2 我们需要哪些编译器
- 这个OS采用C语言与汇编语言编写，那么C语言编译器采用**gcc**，汇编编译器采用nasm。一定要使用汇编语言，是因为高级语言**无法修改寄存器**。
## 1.3 操作系统的宿主环境
- `虚拟机：`虚拟机就是用软件来模拟硬件，虚拟机只是一个普通进程，该进程模拟了硬件资源，在虚拟机中运行的程序其所做出的任何行为都先被虚拟机检查，由虚拟机分析后，代为象操作系统申请。虚拟机在宿主机上只是一个**进程**
# 参考
- [《操作系统真象还原》，作者郑钢](https://book.douban.com/subject/26745156/)